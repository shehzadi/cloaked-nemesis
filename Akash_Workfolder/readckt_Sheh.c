//Akash
//For Debugging the fault
// % /usr/usc/bin/gdb (program name)
// % r for run
// % bt for bac trace to the problem
//Akash

/*=======================================================================
  A simple parser for "self" format

  The circuit format (called "self" format) is based on outputs of
  a ISCAS 85 format translator written by Dr. Sandeep Gupta.
  The format uses only integers to represent circuit information.
  The format is as follows:

1        2        3        4           5           6 ...
------   -------  -------  ---------   --------    --------
0 GATE   outline  0 IPT    #_of_fout   #_of_fin    inlines
                  1 BRCH
                  2 XOR(currently not implemented)
                  3 OR
                  4 NOR
                  5 NOT
                  6 NAND
                  7 AND

1 PI     outline  0        #_of_fout   0

2 FB     outline  1 BRCH   inline

3 PO     outline  2 - 7    0           #_of_fin    inlines




                                    Author: Chihang Chen
                                    Date: 9/16/94

=======================================================================*/

/*=======================================================================
  - Write your program as a subroutine under main().
    The following is an example to add another command 'lev' under main()

enum e_com {READ, PC, HELP, QUIT, LEV};
#define NUMFUNCS 5
int cread(), pc(), quit(), lev();
struct cmdstruc command[NUMFUNCS] = {
   {"READ", cread, EXEC},
   {"PC", pc, CKTLD},
   {"HELP", help, EXEC},
   {"QUIT", quit, EXEC},
   {"LEV", lev, CKTLD},
};

lev()
{
   ...
}
=======================================================================*/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>


#define MAXLINE 81               /* Input buffer size */
#define MAXNAME 31               /* File name size */

#define Upcase(x) ((isalpha(x) && islower(x))? toupper(x) : (x))
#define Lowcase(x) ((isalpha(x) && isupper(x))? tolower(x) : (x))

enum e_com {READ, PC, HELP, QUIT, LEV, LOGIC, FLT_COL, FLT_DRP, ATPG};
enum e_state {EXEC, CKTLD, CKTLVL, CKTCOL};         /* Gstate values */
enum e_ntype {GATE, PI, FB, PO};    /* column 1 of circuit format */
enum e_gtype {IPT, BRCH, XOR, OR, NOR, NOT, NAND, AND};  /* gate types */

struct cmdstruc {
   char name[MAXNAME];        /* command syntax */
   int (*fptr)();             /* function pointer of the commands */
   enum e_state state;        /* execution state sequence */
};

typedef struct n_struc {
   unsigned indx;             /* node index(from 0 to NumOfLine - 1 */ // Values from 0 to Infinity only
   unsigned num;              /* line number(May be different from indx) */
   enum e_gtype type;         /* gate type */ // gates instantiated by this variable
   unsigned fin;              /* number of fanins */	// When fin   = 0, its PI
   unsigned fout;             /* number of fanouts */	// When fout = 0, its PO
   struct n_struc **unodes;   /* pointer to array of up nodes */ //
   struct n_struc **dnodes;   /* pointer to array of down nodes */
   int level;                 /* level of the gate output */
   int numInpsReady;
   int val;
   int possible_values[4];    //possibilities 0, 1, D, and B(D bar) are mapped onto indexes 0,1,2, and 3 respectively. A 1 indicates the value is possible.
   char fault[2];			  /*Fault vaules at each node after Collapsing*/
   char *inivectors[4];		  /* Used to store the vector generated by Transition Delay Faults-- changed to 4 from 2 so   that we can store the patterns for both STR and STF */
   char *vectors[2];		  /* Used to store the vector generated by ATPG */
   // Both are not bit accessible

   // these two are used for test fault insertion
   int has_fault;
   int fault_type; 			 // if has_fault is 1 then this is checked to see if its SA0 or SA1
} NSTRUC;



/*----------------- Command definitions ----------------------------------*/
#define NUMFUNCS 9	//Akash
int cread(), pc(), help(), quit(), lev(), SimpleLogicSimulation(), fault_collapsing(), fault_dropping(), atpg();	//Akash

struct cmdstruc command[NUMFUNCS] = {
   {"READ", cread, EXEC},
   {"PC", pc, CKTLD},
   {"HELP", help, EXEC},
   {"QUIT", quit, EXEC},
   {"LEV", lev, CKTLD},
   {"LOGIC", SimpleLogicSimulation, CKTLD},
   {"FLT_COL", fault_collapsing, CKTLD},
   {"FLT_DRP", fault_dropping, CKTCOL},
   {"ATPG", atpg, CKTCOL}	//Akash
};

/*------------------------------------------------------------------------*/
enum e_state Gstate = EXEC;     /* global exectution sequence */
NSTRUC *Node;                   /* dynamic array of nodes */
NSTRUC **Pinput;                /* pointer to array of primary inputs */
NSTRUC **Poutput;               /* pointer to array of primary outputs */
NSTRUC **PDFront;               // pointer to array of gates on the D frontier;
NSTRUC **PUnjust;               // pointer to array of unjustified lines.
NSTRUC **PBackImp;
NSTRUC **PForwImp;
int NBackImp;
int NForwImp;
int NDFront;                    // number of nodes on the D frontier;
int NUnjust;                    // number of nodes that are unjustified.
int Nnodes;                     /* number of nodes */
int Npi;                        /* number of primary inputs */
int Npo;                        /* number of primary outputs */
int Done = 0;                   /* status bit to terminate program */
/*------------------------------------------------------------------------*/
NSTRUC *sortedNodes = NULL;
int input_vector[5];
int input_vector_pointer;
/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: shell
description:
  This is the main program of the simulator. It displays the prompt, reads
  and parses the user command, and calls the corresponding routines.
  Commands not reconized by the parser are passed along to the shell.
  The command is executed according to some pre-determined sequence.
  For example, we have to read in the circuit description file before any
  action commands.  The code uses "Gstate" to check the execution
  sequence.
  Pointers to functions are used to make function calls which makes the
  code short and clean.
-----------------------------------------------------------------------*/
main()
{
   enum e_com com;
   char cline[MAXLINE], wstr[MAXLINE], *cp;

   while(!Done) {
      printf("\nCommand>");
      fgets(cline, MAXLINE, stdin);
      if(sscanf(cline, "%s", wstr) != 1) continue;
      cp = wstr;
      while(*cp){
	*cp= Upcase(*cp);
	cp++;
      }
      cp = cline + strlen(wstr);
      com = READ;
      while(com < NUMFUNCS && strcmp(wstr, command[com].name)) com++;
      if(com < NUMFUNCS) {
         if(command[com].state <= Gstate) (*command[com].fptr)(cp);
         else printf("Execution out of sequence!\n");
      }
      else system(cline);
   }
}



/*-----------------------------------------------------------------------
input: circuit description file name
output: nothing
called by: main
description:
  This routine reads in the circuit description file and set up all the
  required data structure. It first checks if the file exists, then it
  sets up a mapping table, determines the number of nodes, PI's and PO's,
  allocates dynamic data arrays, and fills in the structural information
  of the circuit. In the ISCAS circuit description format, only upstream
  nodes are specified. Downstream nodes are implied. However, to facilitate
  forward implication, they are also built up in the data structure.
  To have the maximal flexibility, three passes through the circuit file
  are required: the first pass to determine the size of the mapping table
  , the second to fill in the mapping table, and the third to actually
  set up the circuit information. These procedures may be simplified in
  the future.
-----------------------------------------------------------------------*/
cread(cp)
char *cp;
{
   char buf[MAXLINE];
   int ntbl, *tbl, i, j, k, nd, tp, fo, fi, ni = 0, no = 0;
   FILE *fd;
   NSTRUC *np;

   sscanf(cp, "%s", buf);
   if((fd = fopen(buf,"r")) == NULL) {
      printf("File %s does not exist!\n", buf);
      return;
   }
   if(Gstate >= CKTLD) clear();
   Nnodes = Npi = Npo = ntbl = 0;
   while(fgets(buf, MAXLINE, fd) != NULL) {
      if(sscanf(buf,"%d %d", &tp, &nd) == 2) {
         if(ntbl < nd) ntbl = nd;
         Nnodes ++;
         if(tp == PI) Npi++;
         else if(tp == PO) Npo++;
      }
   }
   tbl = (int *) malloc(++ntbl * sizeof(int));

   fseek(fd, 0L, 0);
   i = 0;
   while(fgets(buf, MAXLINE, fd) != NULL) {
      if(sscanf(buf,"%d %d", &tp, &nd) == 2) tbl[nd] = i++;
   }
   allocate();

   fseek(fd, 0L, 0);
   while(fscanf(fd, "%d %d", &tp, &nd) != EOF) {
      np = &Node[tbl[nd]];
      np->num = nd;
      if(tp == PI) Pinput[ni++] = np;
      else if(tp == PO) Poutput[no++] = np;
      switch(tp) {
         case PI:
         case PO:
         case GATE:
            fscanf(fd, "%d %d %d", &np->type, &np->fout, &np->fin);
            break;

         case FB:
            np->fout = np->fin = 1;
            fscanf(fd, "%d", &np->type);
            break;

         default:
            printf("Unknown node type!\n");
            exit(-1);
         }
      np->unodes = (NSTRUC **) malloc(np->fin * sizeof(NSTRUC *));
      np->dnodes = (NSTRUC **) malloc(np->fout * sizeof(NSTRUC *));
      for(i = 0; i < np->fin; i++) {
         fscanf(fd, "%d", &nd);
         np->unodes[i] = &Node[tbl[nd]];
         }
      for(i = 0; i < np->fout; np->dnodes[i++] = NULL);
      }
   for(i = 0; i < Nnodes; i++) {
      for(j = 0; j < Node[i].fin; j++) {
         np = Node[i].unodes[j];
         k = 0;
         while(np->dnodes[k] != NULL) k++;
         np->dnodes[k] = &Node[i];
         }
      }
   fclose(fd);
   Gstate = CKTLD;
   printf("==> OK\n");
}

lev(cp)
char *cp;
{
	Gstate = CKTLVL;

	//void *vectors = (char *) malloc (Npi); // Akash. Done to make a fault vector list

    sortedNodes = (NSTRUC*) malloc(Nnodes*sizeof(NSTRUC));
    printf("=============LEVELIZING===============\n\n");
    int i,j,k, while_cond = 1, max_level, a, swapped=1;
    NSTRUC *np, *tmp_np;

  //  sortedNodes = (NSTRUC *) malloc(Nnodes * sizeof(NSTRUC));
    NSTRUC tempNode;

    for(i=0; i<Nnodes; i++){

        np = &Node[i];

        np->level = -1; //value of -1 denotes that the level is undefined
        np->numInpsReady = 0;

    }

    for(i=0; i<Nnodes; i++){

        np = &Node[i];
        if(np->type==0){
            np->level = 0;

            levelize_depth(np);
        }

    }
    printf("Sorting nodes based on levels...\n\n");
    //sort into an array of nodes

    for(a=0; a<Nnodes; a++){
        sortedNodes[a] = Node[a];
    }


    while(swapped==1){
     swapped = 0;
     for(a = 1; a<Nnodes; a++){
       /* if this pair is out of order */
         if((sortedNodes[a-1].level)>(sortedNodes[a].level)){
             tempNode = sortedNodes[a-1];
             sortedNodes[a-1] = sortedNodes[a];
             sortedNodes[a] = tempNode;
             swapped = 1;
         }

         /* if A[i-1] > A[i] then
          swap them and remember something changed
         swap( A[i-1], A[i] )
         swapped = true
       end if */
     }
    }
    printf("Nodes have been sorted.\n\n");
    printf("Printing out sorted nodes\n\n");
    for(a=0; a<Nnodes; a++){
        printf("Node %d level %d\n", sortedNodes[a].num, sortedNodes[a].level);
    }


    for(i = 0; i < Nnodes; i++) {
      for(j = 0; j < sortedNodes[i].fin; j++) {
         np = sortedNodes[i].unodes[j];
         k = 0;
         while(np->dnodes[k] != NULL) k++;
         np->dnodes[k] = &sortedNodes[i];
         }
      }

}

levelize_depth(xp)
NSTRUC *xp;
{
    NSTRUC *tmp_np;
    int j,k, max_level;
    printf("Level of node %d is %d\n", xp->num, xp->level);
    for(j=0; j<xp->fout; j++){
                tmp_np = xp->dnodes[j];
                tmp_np->numInpsReady++;
                if(tmp_np->numInpsReady==tmp_np->fin){
                    max_level = 0;
                    for(k=0; k< tmp_np->fin; k++){
                        if(max_level<tmp_np->unodes[k]->level)
                            max_level = tmp_np->unodes[k]->level;
                    }
                    tmp_np ->level = max_level + 1;
                    levelize_depth(tmp_np);
                }

            }

}
/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: main
description:
  The routine prints out the circuit description from previous READ command.
-----------------------------------------------------------------------*/
pc(cp)
char *cp;
{
   int i, j;
   NSTRUC *np;
   char *gname();

   printf(" Node   Type \tIn     \t\t\tOut    \n");
   printf("------ ------\t-------\t\t\t-------\n");
   for(i = 0; i<Nnodes; i++) {
      np = &Node[i];
      printf("\t\t\t\t\t");
      for(j = 0; j<np->fout; j++) printf("%d ",np->dnodes[j]->num);
      printf("\r%5d  %s\t", np->num, gname(np->type));
      for(j = 0; j<np->fin; j++) printf("%d ",np->unodes[j]->num);
      printf("\n");
   }
   printf("Primary inputs:  ");
   for(i = 0; i<Npi; i++) printf("%d ",Pinput[i]->num);
   printf("\n");
   printf("Primary outputs: ");
   for(i = 0; i<Npo; i++) printf("%d ",Poutput[i]->num);
   printf("\n\n");
   printf("Number of nodes = %d\n", Nnodes);
   printf("Number of primary inputs = %d\n", Npi);
   printf("Number of primary outputs = %d\n", Npo);
}

/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: main
description:
  The routine prints ot help inormation for each command.
-----------------------------------------------------------------------*/
help()
{
   printf("READ *filename* - ");
   printf("read in circuit file and creat all data structures\n");
   printf("PC - ");
   printf("print circuit information\n");
   printf("HELP - ");
   printf("print this help information\n");
   printf("QUIT - ");
   printf("stop and exit\n");
   printf("LEV - ");
   printf("start Levelization Procedure\n");
   printf("LOGIC - ");
   printf("logic simulation of random vectors\n");
   printf("FLT_COL - ");
   printf("Fault Collapsing\n");
   printf("FLT_DRP - ");
   printf("Fault Dropping\n");
   printf("APTG - ");
   printf("Run D-Algorith for finding Fault Detection Vectors \n");
   printf(" - ");

   printf("\n");
}

/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: main
description:
  Set Done to 1 which will terminates the program.
-----------------------------------------------------------------------*/
quit()
{
   Done = 1;
}

/*======================================================================*/

/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: cread
description:
  This routine clears the memory space occupied by the previous circuit
  before reading in new one. It frees up the dynamic arrays Node.unodes,
  Node.dnodes, Node.flist, Node, Pinput, Poutput, and Tap.
-----------------------------------------------------------------------*/
clear()
{
   int i;

   for(i = 0; i<Nnodes; i++) {
      free(Node[i].unodes);
      free(Node[i].dnodes);
   }
   free(Node);
   free(Pinput);
   free(Poutput);
   Gstate = EXEC;
}

/*-----------------------------------------------------------------------
input: nothing
output: nothing
called by: cread
description:
  This routine allocatess the memory space required by the circuit
  description data structure. It allocates the dynamic arrays Node,
  Node.flist, Node, Pinput, Poutput, and Tap. It also set the default
  tap selection and the fanin and fanout to 0.
-----------------------------------------------------------------------*/
allocate()
{
   int i;

   Node = (NSTRUC *) malloc(Nnodes * sizeof(NSTRUC));
   Pinput = (NSTRUC **) malloc(Npi * sizeof(NSTRUC *));
   Poutput = (NSTRUC **) malloc(Npo * sizeof(NSTRUC *));
   for(i = 0; i<Nnodes; i++) {
      Node[i].indx = i;
      Node[i].fin = Node[i].fout = 0;
   }
}

/*-----------------------------------------------------------------------
input: gate type
output: string of the gate type
called by: pc
description:
  The routine receive an integer gate type and return the gate type in
  character string.
-----------------------------------------------------------------------*/
char *gname(tp)
int tp;
{
   switch(tp) {
      case 0: return("PI");
      case 1: return("BRANCH");
      case 2: return("XOR");
      case 3: return("OR");
      case 4: return("NOR");
      case 5: return("NOT");
      case 6: return("NAND");
      case 7: return("AND");
   }
}

SimpleLogicSimulation(cp)
char *cp;
	{
	if(Gstate != CKTLVL)	//Akash
	{
		lev(NULL);
		Gstate = CKTLVL;
	}

		int i,j;

                for(i=0; i<Nnodes; i++){
                    sortedNodes[i].val = 0;
                }

           for(j=0; j<5; j++){
                printf("\nGenerating Random Input Vector %d\n", j);
                for(i=0; i<Npi; i++){
                    input_vector[i] = rand()%2;
                    input_vector_pointer = 0;
                    printf("Value of input node %d = %d\n", sortedNodes[i].num, input_vector[i]);
                }

		for(i=0; i<Nnodes; i++){
                    node_eval(i);

		}
                for(i=0; i<Nnodes; i++){
                    if(sortedNodes[i].fout==0){
                        printf("Output of node %d is %d\n", sortedNodes[i].num, sortedNodes[i].val);
                    }
                }

              //  for(i=0; i<Nnodes; i++){

                //  printf("value of node %d is %d and fin is %d. Input node [0] is %d with value %d \n", sortedNodes[i].num, sortedNodes[i].val, sortedNodes[i].fin, sortedNodes[i].unodes[0]->num, getNodeVal(sortedNodes[i].unodes[0]->num) );

             //   }
                printf("\n\n");
           }

	}

node_eval(xp)
int xp;
	{
    int i, temp1, temp2;
		if(gname(sortedNodes[xp].type)=="PI"){
                 //   printf("adding value &d to node %d\n", input_vector[sortedNodes[xp].num-1], sortedNodes[xp].num);
			sortedNodes[xp].val = input_vector[input_vector_pointer];
                        input_vector_pointer++;//input vector is a 5 location array that has values 1, 0 or -1(aka X)
		}else if (gname(sortedNodes[xp].type)=="BRANCH"){
			sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);

		}else if(gname(sortedNodes[xp].type)=="NOT"){
                    if(getNodeVal(sortedNodes[xp].unodes[0]->num)==0){
                        sortedNodes[xp].val = 1;
                    }else if(getNodeVal(sortedNodes[xp].unodes[0]->num)==1){
                        sortedNodes[xp].val = 0;
                    }else{
                        sortedNodes[xp].val = -1;
                    }
                }else if (gname(sortedNodes[xp].type)=="AND"){
			//create functions for AND, OR, NAND, NOR, and XOR that

                    if(sortedNodes[xp].fin>1){
                //        printf("AND with more than 1 input\n");
                        for(i=0; i<=sortedNodes[xp].fin-2; i++){
                            if(i==0){
                                temp1 = AND_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
                            }else{

                                temp1 = AND_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
                            }

                        }
                        sortedNodes[xp].val = temp1;
                    }else{
              //          printf("AND with 1 input\n");
                        sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
                       // printf("Assigned value %d to node %d because upnode[0] has value. Upnode node is %d out of %d nodes\n", sortedNodes[xp].val, sortedNodes[xp].num, sortedNodes[xp].unodes[xp]->num, sortedNodes[xp].fin);
                    }
		}else if (gname(sortedNodes[xp].type)=="OR"){
			//create functions for AND, OR, NAND, NOR, and XOR that
                  //  printf("found OR gate for node %d with fin &d\n", sortedNodes[xp].num, sortedNodes[xp].fin);
                    if(sortedNodes[xp].fin>1){
                        for(i=0; i<=(sortedNodes[xp].fin-2); i++){
                            if(i==0){
                              //  printf("calling OR function for the first time for node %d with inputs %d and %d\n", sortedNodes[xp].num,sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num);
                                temp1 = OR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
                            }else{

                                temp1 = OR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
                            }

                        }
                        sortedNodes[xp].val = temp1;
                    }else{
                        sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
                    }
		}else if (gname(sortedNodes[xp].type)=="NAND"){
			//create functions for AND, OR, NAND, NOR, and XOR that
                    if(sortedNodes[xp].fin>1){
                        for(i=0; i<=sortedNodes[xp].fin-2; i++){
                            if(i==0){
                                temp1 = NAND_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
                            }else{

                                temp1 = NAND_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
                            }

                        }
                        sortedNodes[xp].val = temp1;
                    }else{
                        sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
                    }
		}else if (gname(sortedNodes[xp].type)=="NOR"){
			//create functions for AND, OR, NAND, NOR, and XOR that
                    if(sortedNodes[xp].fin>1){
                        for(i=0; i<=sortedNodes[xp].fin-2; i++){
                            if(i==0){
                                temp1 = NOR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
                            }else{

                                temp1 = NOR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
                            }

                        }
                        sortedNodes[xp].val = temp1;
                    }else{
                        sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
                    }
		}else if (gname(sortedNodes[xp].type)=="XOR"){
			//create functions for AND, OR, NAND, NOR, and XOR that
                    if(sortedNodes[xp].fin>1){
                        for(i=0; i<=sortedNodes[xp].fin-2; i++){
                            if(i==0){
                                temp1 = XOR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
                            }else{

                                temp1 = XOR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
                            }

                        }
                        sortedNodes[xp].val = temp1;
                    }else{
                        sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
                    }
		}
	}

int AND_gate(int A, int B){
	if((A==0) | (B==0)){
		return(0);
	}else if(A==1){
		return(B);
	}else if(B==1){
		return(A);
	}else{
		return(-1);
	}
}

int NAND_gate(int A, int B){
	if(AND_gate(A,B)==1){
		return(0);
	}else if(AND_gate(A,B)==0){
		return(1);
	}else{
		return(-1);
	}
}

int OR_gate(int A, int B){
	if((A==1) | (B==1)){
		return(1);
	}else if(A==0){
		return(B);
	}else if(B==0){
		return(A);
	}else{
		return(-1);
	}
}

int NOR_gate(int A, int B){
	if(OR_gate(A,B)==1){
		return(0);
	}else if(OR_gate(A,B)==0){
		return(1);
	}else{
		return(-1);
	}
}

int XOR_gate(int A, int B){
    if((A==1 && B==1)|(A==0 && B==0)){
        return(0);
    }else if (A==-1 | B==-1){
        return(-1);
    }else{
        return(1);
    }
}
/*========================= End of program ============================*/

int getNodeVal(num)
int num;
{
    int i;
    for(i=0; i<Nnodes; i++){
        if(sortedNodes[i].num==num){
      //      printf("Returning node %d's value\n",num);
            return(sortedNodes[i].val);
        }
    }
}

/*setNodeVal(int num, int val)
{
    int i;
    for(i=0; i<Nnodes; i++){
        if(sortedNodes[i].num==num){
            sortedNodes[i].val = val;
            printf("Setting value of node &d to %d", num, val);
        }
    }
}
*/



//#ifdef 1
//Akash
//======================================Start of Project Code=====================================
//Some points to help in Coding
//Accessing a member in a node (with an example):
    //– NSTRUC *np;
    //– np = &Node[node_num];
    //– np->indx = 6;
//

//=================================================================================================

//==================================FAULT COLLAPSING START======================================
fault_collapsing()
{
	void *vectors = (char *) malloc (Npi); // Akash. Done to make a fault vector list

	gen_faults();
	print_faults();

	//Node[1].vectors[1][1] = "0";

	Node[1].vectors[1] = "00000";
	Node[1].vectors[0] = "010x0";

	printf("\nval0: %s ", Node[1].vectors[0]);
	printf("\nval1: %s ", Node[1].vectors[1]);
	printf("\n");

	// For initialization if needed
	// for(i = 0; i < Nnodes; i++)
	// {
		// Node[i].vectors[0] = "xxxxx"; // considering everything is not defined in the begining
		// Node[i].vectors[1] = "xxxxx";
	// }

	Gstate = CKTCOL;	// Stating that the circuit is done for Fault Collapsing and that a file has been generated for it
}

gen_faults()	// - Done
{
	int i,j;

	NSTRUC *fltsc;


	//if(sortedNodes == NULL)//works
	if(Gstate != CKTLVL)
	{
		lev(NULL);
	}

    printf("\n=================== Fault Collapsing =================\n");


	printf("\n Total Nnodes: %d \n", Nnodes);
	//This is done here so that we can assign faults and then drop easily
	// Only for own method
	for(i = 0; i < Nnodes; i++)
	{
		Node[i].fault[0] = '1'; // considering everything is required in the beginning
		Node[i].fault[1] = '1';
		//add more similarly if you want to add valid data
	}


	for(i = Nnodes - 1; i >=0; i--)
	{
		printf("\n\n");
		fltsc = &(sortedNodes[i]); // to facilitate start or calculation from the PO

		printf("Printing level : %d & Gate_Type : %s \n", sortedNodes[i].level, gname(sortedNodes[i].type));

		//Since already initialized, we can now remove PI and Branch
		if((fltsc->type >=0) && (fltsc->type <8))	//Branch also has to be included including IPT. Only avoid not defined ones
		{
			printf("Starting to Drop Faults For this Gate and indx: %d\n", (fltsc->indx));
			//printf("Input Nodes: %d, Output Nodes: %d \n",Node[i].unodes, Node[i].dnodes);
			//printf("\t	Fin Value: %d	\n", Node[i].fin);
			//printf("\t	Fout Value: %d	\n", Node[i].fout);

			/*
			printf("Input Nodes:");
			if(Node[i].fin==0)
				printf("  %d  ",(Node[i].unodes[0])->indx);
			else
				for(j = 0; j < (Node[i].fin); j++)
				{
					printf("  %d  ",(Node[i].unodes[j])->indx);
				}
			printf("\n");

			printf("Output Nodes:");
			if(Node[i].fout==0)
				printf("  %d  ",(Node[i].dnodes[0])->indx);
			else
				for(j = 0; j < (Node[i].fout); j++)
					printf("  %d  ",(Node[i].dnodes[j])->indx);
			*/

			//printf("\n");
			fault_drop_col(fltsc->indx);
		}
	}



	printf("\n\n================ Final Fault List ======================== \n");
	for(i = Nnodes -1; i >=0; i--)
	{
		printf("Line : %d, Level: %d, Stuck-at-Faults: %s \n", Node[i].num, Node[i].indx, Node[i].fault);
	}

}

fault_drop_col(int flt_indx) // - DONE
{
	int i;
	//int flag;
	int temp_loc;
	NSTRUC *np;

	//Node[flt_indx].fault[0] = '1'; // considering everything is required in the beginning
	//Node[flt_indx].fault[1] = '1';
	//Cannot do this here as it might cause problems to already removed faults at output of gate


	//printf("\t	Type in Function: %s\t", gname(Node[flt_indx].type));
	//printf("\t	Fin Value: %d	\n", Node[flt_indx].fin);
	//printf("\t	Index: %d\t	\n", Node[flt_indx].indx); // Correct Values

	switch(Node[flt_indx].type)
	{
		//Works for both AND and NOR. Same Code
		case AND:
		case NOR:

			//Algorithm
				// if output 0 is high, make it 0
				// and make any one input0 to 0
				// (here check if one is connected to XOR,
				// then this one should be removed)

				// If the gate is a branch, nothing can be done
				// Both should remain 1

				//printf("\t	Before Fault: %c \t %c \n", Node[flt_indx].fault[0], Node[flt_indx].fault[1]);

				//flt_indx because it is the output of the gate
				Node[flt_indx].fault[1] = '0';	//Dominance Relation // correct
				Node[flt_indx].fault[0] = '0';	//Equivalence Relation // correct

				//printf("\t	After Fault: %c \t %c \n", Node[flt_indx].fault[0], Node[flt_indx].fault[1]);

			if(Node[flt_indx].fin < 1)
				{printf("\n");}
			else
			for(i = 0; i < Node[flt_indx].fin-1; i++)	// fin-1 to save one location with the fault
			{
				temp_loc = ((Node[flt_indx].unodes[i])->indx);
				printf("Working on indx: %d, \n", temp_loc);
				Node[temp_loc].fault[0] = '0';	//Equivalence Relation
			}
			break;

		//Works for both OR and NAND. Same Code
		case OR:
		case NAND:

				//printf("Index: %d, \n", flt_indx);
			 //Algorithm
				// if output 1 is high, make it 0
				// and make any one input1 to 0
				// (here check if one is connected to XOR,
				// then this one should be removed)

				// If the gate is a branch, nothing can be done
				// Both should remain 1


				//printf("\t	Before Fault: %c \t %c \n", Node[flt_indx].fault[0], Node[flt_indx].fault[1]);

				//flt_indx because it is the output of the gate
				Node[flt_indx].fault[0] = '0';	//Dominance Relation // correct
				Node[flt_indx].fault[1] = '0';	//Equivalence Relation // correct

				//printf("\t	After Fault: %c \t %c \n", Node[flt_indx].fault[0], Node[flt_indx].fault[1]);

			if(Node[flt_indx].fin < 1)
				{printf("\n");}
			else
			for(i = 0; i < Node[flt_indx].fin-1; i++)
			{
				temp_loc = ((Node[flt_indx].unodes[i])->indx);
				printf("Working on indx: %d, \n", temp_loc);
				Node[temp_loc].fault[1] = '0';	//Equivalence Relation
			}
			break;

		//NOT and XOR does not have a dominance relationship
		case NOT:
		case XOR:
		case IPT:
		case BRCH:
			printf("No Fault Collapsing possible for this gate\n");
			break;
		default:
			printf("This is not a primitive gate");
	}
	//printf("Need to evaluate \n");
}


print_faults() // - Done
{
	int i;

	FILE *flts;

	if((flts = fopen("fault_list.txt","w")) == NULL)
	{
		printf("Cannot create the file\n");
		return;
	}

	for(i = 0; i < Nnodes; i++)
	{
		if(Node[i].fault[0] == '1') // Stuck at 0 Fault
		{
			//fprintf(flts,"%d %d %c \n", Node[i].num, Node[i].indx,'0');
			fprintf(flts,"%d %c \n", Node[i].num,'0');
		}

		if(Node[i].fault[1] == '1') // Stuck at 1 Fault
		{
			//fprintf(flts,"%d %d %c \n", Node[i].num, Node[i].indx,'1');
			fprintf(flts,"%d %c \n", Node[i].num,'1');
		}
	}

	fclose(flts);
}
//==================================FAULT COLLAPSING END=================================


//============================FAULT DROPPING START=================================

/*
Example of Passing an array to a function
int add( int * p, int n ) {
   int total = 0;
   for ( int i = 0; i < n; i++ ) {
       total += p[i];
   }
   return total;
}


int main() {
    int a[] = { 1, 7, 42 };
    int n = add( a, 3 );
}
*/

//need to pass a char as it might also include x or any of 0 or 1
fault_dropping(char *vec_test) // - In Process // Akash
{
	printf("Trying to Drop Faults with new Vector\n");

	// ** ALGORITHM **

	// You start with a vector which you need to check if helps in collapsing
	// After getting the vector, we need to check the list for the remaining faults (for loop or while loop)
	// We might need two variable as loop variables (or just flag), one for indx and the other is stk 0 or 1 checking value
	// We need to pick one fault and excite the fault (includes initialization of X and Kai)
	// After doing that, we will have to do fault simulation with the provided vector.
	// Main point is to make sure in simulation is that we do not overwrite the fault which we excited
	// The vector that we applied can also be made more specific
	// After complete simulation, we need to check if any of the PO has D or B as its output
	// This above step has to be done by logic simulation function
	// If we get that, we send back 1 to flt_drp function or flt_drp gets 0
	// After coming back, we check the return value. So its a variable
	// If the value is one, then that gate fault accessed before can now be removed
	//

	int flag = 0; // to set the start at SA0
	int i;
	int pass = 0;

	int temp;

	FILE *flt_vec;

	if((flt_vec = fopen("Vector_list.txt","w")) == NULL)
	{
		printf("Cannot create the file\n");
		return;
	}

	//=========Can add something if we need to make the values specific=======
	// for(i = 0; i < strlen(vec_test); i++)
	// {
		// if(vec_test[i] == 'x')
		// {
			// i actually believe that we should do it randomly and not pre-determined :P

			// temp = rand() % 2;	// to choose from either 0 or 1. So take a mod
			// vec_test[i] = (char)(((int)'0')+temp);; // Int to Char conversion

			//Only above function works properly
		// }

	// }
	//=========Can add something if we need to make the values specific=======



	//===============To check for every remaining fault=========================
	for(i == Nnodes-1; i >=0; i--)
	{
		for(flag = 0; flag <2; flag ++) // had to make loop to save
		{
			if(Node[i].fault[flag] == '1')	// 1 says that the fault is active and not yet removed
			{
				initialize_fault(i, flag);	// we excite the fault location and type of fault
				pass = logic_drop(vec_test, i); // want to simulate the logic
				// i want the logic simulation to actually give me pass or fail
				if(pass == 1) // pass == 1 drops the fault
				{
					Node[i].fault[flag] = '0';
					printf("\nThe vector was able to detect this fault\n");
					fprintf(flt_vec,"%d %s \n", Node[i].num, vec_test);
				}
			}
			//else
			// not needed as if its not active fault,
			//we do not need to check it
		}

	}
	//===============To check for every remaining fault=========================

	fclose(flt_vec);

}
//============================FAULT DROPPING END====================================




//==================Copying of Fault Vectors to Collapsing faults START============
flt_vec_coll()
{
	int i,j;

	NSTRUC *vecc;

    printf("\n=================== Vector Collapsed =================\n");


	printf("\n Total Nnodes: %d \n", Nnodes);

	for(i = 0; i < Nnodes - 1; i--)	//Incremental because vectors for lower vectors are known
	{
		printf("\n\n");
		vecc = &(sortedNodes[i]); // to facilitate start or calculation from the PI

		printf("Printing level : %d & Gate_Type : %s \n", sortedNodes[i].level, gname(sortedNodes[i].type));

		// Check if the types can remove IPT and branch
		if((vecc->type >=0) && (vecc->type <8))	//Branch also has to be included including IPT. Only avoid not defined ones
		{
			printf("Starting to Drop Faults For this Gate and indx: %d\n", (vecc->indx));

			vec_col(vecc->indx);
		}
	}
}

vec_col(int vec_indx)	// Still need to find dominance relationship
{
	int i;
	int eq_loc;
	int dom_loc;

	NSTRUC *np;

	//printf("\t	Type in Function: %s\t", gname(Node[vec_indx].type));
	//printf("\t	Fin Value: %d	\n", Node[vec_indx].fin);
	//printf("\t	Index: %d\t	\n", Node[vec_indx].indx); // Correct Values

	switch(Node[vec_indx].type)
	{
		//Works for both AND and NOR. Same Code
		case AND:
		case NOR:

			//Algorithm
				//Check the fault vector at the only node where fault was not collapsed
				//Copy this to all the other Fan ins and also the equivalence realtion at the output

				//printf("\t	Before Fault: %c \t %c \n", Node[vec_indx].fault[0], Node[vec_indx].fault[1]);

			if(Node[vec_indx].fin < 1)	//not possible if it is a AND OR NOR GATE :P
				{printf("\n");}
			else
			{
				dom_loc = ((Node[vec_indx].unodes[Node[vec_indx].fin-1])->indx);
				Node[vec_indx].vectors[1] = Node[dom_loc].vectors[1];	//Dominance Relation To Output

				eq_loc = ((Node[vec_indx].unodes[Node[vec_indx].fin-1])->indx);	// To check the only fault not collapsed
				Node[vec_indx].vectors[0] = Node[eq_loc].vectors[0];	//Equivalence Relation To Output

				for(i = 0; i < Node[vec_indx].fin-1; i++)
				{
					printf("Working on indx: %d, \n", eq_loc);
					Node[i].vectors[0] = Node[eq_loc].vectors[0];	//Equivalence Relation To Input
				}

			}
			break;

		//Works for both OR and NAND. Same Code
		case OR:
		case NAND:
				//Algorithm
				//Check the fault vector at the only node where fault was not collapsed
				//Copy this to all the other Fan ins and also the equivalence realtion at the output

				if(Node[vec_indx].fin < 1)	//not possible if it is a AND OR NOR GATE :P
				{printf("\n");}
				else
				{
					dom_loc = ((Node[vec_indx].unodes[Node[vec_indx].fin-1])->indx);
					Node[vec_indx].vectors[0] = Node[dom_loc].vectors[0];	//Dominance Relation To Output

					eq_loc = ((Node[vec_indx].unodes[Node[vec_indx].fin-1])->indx);	// To check the only fault not collapsed
					Node[vec_indx].vectors[1] = Node[eq_loc].vectors[1];	//Equivalence Relation To Output

					for(i = 0; i < Node[vec_indx].fin-1; i++)
					{
						printf("Working on indx: %d, \n", eq_loc);
						Node[i].vectors[1] = Node[eq_loc].vectors[1];	//Equivalence Relation To Input
					}

				}
			break;

		//NOT and XOR does not have a dominance relationship
		case NOT:
		case XOR:
		case IPT:
		case BRCH:
			printf("No Fault Collapsing was done for this gate\n");
			break;
		default:
			printf("This is not a primitive gate");
	}
}
//==================Copying of Fault Vectors to Collapsing faults END===============



//==============================D ALGO START============================================
atpg()
{
    int fault_list[Nnodes*2][3];
    int i = 0;

    //Generating an array with all the valid faults left after collapsing.
    //fault_list[0] is the line index
    //fault_list[1] is 0 for stuck at 0 fault, 1 for stuck at 1 fault
    //fault_list[2] is a valid bit that says whether or not this fault still needs to be tested
    while(i < Nnodes*2){

	fault_list[i][0] = Node[i].indx;
        fault_list[i+1][0] = Node[i].indx;

        fault_list[i][1] = 0;
        fault_list[i][1] = 1;


	if(Node[i].fault[0]=='1'){
            fault_list[i][2] = 1;
        }else{
            fault_list[i][2] = 0;
        }

	if(Node[i+1].fault[1]=='1'){
            fault_list[i+1][2] = 1;
        }else{
            fault_list[i+1][2] = 0;
        }

        i = i+2;
    }

    //Checking work:: Print fault array to confirm with fault list
    for(i = 0; i < Nnodes*2; i++){
        printf("Index: %d; Stuck at fault: %d; Valid: %d \n", fault_list[0], fault_list[1], fault_list[2]);
    }

    for(i = 0; i < Nnodes*2; i++){
        if(fault_list[i][2] == 1){
            initialize_fault(fault_list[i][0], fault_list[i][1]);

            while(!((AnyOutputOnlyFault() == 1) && (NUnjust == 0))){

            }


        }
    }
    //run a for loop through the array
    //if fault is not valid don't do anything for this fault
    //else do initialization
    //after initialization run implication and algo to find vector
    //pass on to fault dropping
    // next vector and fault
}

initialize_fault(int a, int b)
{
    int i,x;
    for(i = 0; i < Nnodes; i++){

        Node[i].possible_values[0] = 1;
        Node[i].possible_values[1] = 1;
        Node[i].possible_values[2] = 0;
        Node[i].possible_values[3] = 0;

        //target fault insertion
        if(Node[i].indx == a){

            Node[i].has_fault = 1;
            Node[i].fault_type = b;

            if(b == 1){

                Node[i].possible_values[3] = 1;
                Node[i].possible_values[0] = 0;
                Node[i].possible_values[1] = 0;

            }

            else if(b == 0){

                Node[i].possible_values[2] = 1;
                Node[i].possible_values[0] = 0;
                Node[i].possible_values[1] = 0;

            }

        }else{

            Node[i].has_fault = 0;

        }
    }

    fault_fanout_init(a);
}

fault_fanout_init(int node_index)
{
    int i;

    for(i = 0; i < Node[node_index].fout; i++){

        Node[node_index].dnodes[i]->possible_values[0] = 1;
        Node[node_index].dnodes[i]->possible_values[1] = 1;
        Node[node_index].dnodes[i]->possible_values[2] = 1;
        Node[node_index].dnodes[i]->possible_values[3] = 1;

        fault_fanout_init(Node[node_index].dnodes[i]->indx);
    }

}
/*
 NSTRUC *Node;                   // dynamic array of nodes /
NSTRUC **Pinput;                /* pointer to array of primary inputs /
NSTRUC **Poutput;               /* pointer to array of primary outputs /
NSTRUC **PDFront;               // pointer to array of gates on the D frontier;
NSTRUC **PUnjust;               // pointer to array of unjustified lines.
int NDFront;                    // number of nodes on the D frontier;
int NUnjust;                    // number of nodes that are unjustified.
int Nnodes;                     /* number of nodes /
int Npi;                        /* number of primary inputs /
int Npo;                        /* number of primary outputs /
int Done = 0;                   /* status bit to terminate program /
NSTRUC **PBackImp;
NSTRUC **PForwImp;
int NBackImp;
int NForwImp;
 */


int AnyOutputOnlyFault(){

    int i, FaultDetected, NonFaultDetected;

    for(i=0; i<Npo; i++){

        FaultDetected = 0;
        NonFaultDetected = 0;

        FaultDetected = Poutput[i]->possible_values[2] | Poutput[i]->possible_values[3] | FaultDetected;
        NonFaultDetected = Poutput[i]->possible_values[0] | Poutput[i]->possible_values[2] | NonFaultDetected;

        if((NonFaultDetected == 0) && (FaultDetected == 1)){
            return(1);
        }

    }

    return(0);
}

int AllOutputsOnlyNotFault(){

    int i, FaultDetected, NonFaultDetected;

    FaultDetected = 0;
    NonFaultDetected = 0;

    for(i=0; i<Npo; i++){

        FaultDetected = Poutput[i]->possible_values[2] | Poutput[i]->possible_values[3] | FaultDetected;
        NonFaultDetected = Poutput[i]->possible_values[0] | Poutput[i]->possible_values[2] | NonFaultDetected;

    }

    if((NonFaultDetected == 1) && (FaultDetected == 0)){
        return(1);
    }

    return(0);

}


forward_implication(int node_index){
    //Need to add code for branch, inverter, three input gates, and
    //This code is working for only a 2 input 1 output gate
    int i,j, changed;
    int temp_output_possib[4];




    for(i = 0; i < 4; i++)
	{
        if(Node[node_index].unodes[0]->possible_values[i] == 1)
		{
            for(j = 0; j < 4; j++)
			{
				if(Node[node_index].unodes[1]->possible_values[i] == 1)
				{//my input j has a possibility of having this particular value then only
					if(gname(Node[node_index].type) == "AND")
					{
                        temp_output_possib[AND_4TT(i,j)] == 1;
                    }
					else if(gname(Node[node_index].type) == "NAND")
					{
                        temp_output_possib[NAND_4TT(i,j)] == 1;
                    }
					else if(gname(Node[node_index].type) == "OR")
					{
                        temp_output_possib[OR_4TT(i,j)] == 1;
                    }
					else if(gname(Node[node_index].type) == "NOR")
					{
                        temp_output_possib[NOR_4TT(i,j)] == 1;
                    }
					else if(gname(Node[node_index].type) == "XOR")
					{
                        temp_output_possib[XOR_4TT(i,j)] == 1;
                    }
                }
            }
        }
    } // At the end of this for loop I have an array of possible values that can be implied by the inputs.

    //compare

    changed = 0;
    for(i=0; i<4; i++){

        if((temp_output_possib[i] == 0) && (Node[node_index].possible_values[i] == 1) && (changed == 0)){

            changed = 1;

        }

        if((temp_output_possib[i] == 0) && (Node[node_index].possible_values[i] == 1)){

            Node[node_index].possible_values[i] = temp_output_possib[i];
            //Need to create another forward implication for every node in the fanout of
            //Posible that we shouldnt be calling forward implication here because a higher function caller needs to inspect the changed variable and the conflict and success varibales
            for(j=0; j<Node[node_index].fout; j++){

                forward_implication(Node[node_index].dnodes[j]->indx);

            }


        }

        //might have to ad code here saying that if output_possib[i] == 1 and node_possib is 0 that means unjustified

    }





    //union city 31055 court house drive, grand slam
}

int AND_4TT(int A, int B){
	if((A==0) | (B==0)){
		return(0);
	}else if(A==1){
		return(B);
	}else if(B==1){
		return(A);
	}else if(A==B){
		return(A);
	}else{
            return(0);
        }
}

int NAND_4TT(int A, int B){
	if(AND_4TT(A,B)==1){
		return(0);
	}else if(AND_4TT(A,B)==0){
		return(1);
	}else if(AND_4TT(A,B)==3){
                return(2);
	}else if(AND_4TT(A,B)==2){
                return(3);
        }
}

int OR_4TT(int A, int B){
	if((A==1) | (B==1)){
		return(1);
	}else if(A==0){
		return(B);
	}else if(B==0){
		return(A);
	}else if(A==B){
		return(A);
	}else{
            return(1);
        }
}

int NOR_4TT(int A, int B){
	if(OR_4TT(A,B)==1){
		return(0);
	}else if(OR_4TT(A,B)==0){
		return(1);
	}else if(OR_4TT(A,B)==3){
                return(2);
	}else if(OR_4TT(A,B)==2){
                return(3);
        }
}

int XOR_4TT(int A, int B){
    if(A==B){
        return(0);
    }else if (A==0){
        return(B);
    }else if (B==0){
        return(A);
    }else if (A==1){
        if(B==2){
            return(3);
        } else if(B==3){
            return(2);
        }
    }else if (B==1){
        if(A==2){
            return(3);
        }else if(A==3){
            return(2);
        }
    }else{
        return(1);
    }
}


//==============================D ALGO END============================================

// Important points to which answers are needed
// Making a struct variable vector[2][Npi]. Here Npi might not be ready  // Done // I am so great
// Finding a fault vector for dominant faults // Done // I am so great
// Need to assign the fault vectors from one equivalence to another // Done for Equivalence and Dominance // I am so great
// Need to check if fault collapsing can be done for Transition delay
// Need to check input values if fault site is PI


//==============================TRANSITION DELAY FAULTS START===========================
tran_delay()
{
	void *inivectors = (char *) malloc (Npi); // Akash. Done to make a fault vector list
	int loc_indx;

	// To explain to you how it works
	// Node[1].inivectors[1] = "00000";
	// Node[1].inivectors[0] = "010x0";

	// printf("\nval0: %s ", Node[1].inivectors[0]);
	// printf("\nval1: %s ", Node[1].inivectors[1]);
	// printf("\n");

	int i, j, k, l;
	int flag;
	// For initialization if needed
	for(i = 0; i < Nnodes; i++)
	{
		if(Node[i].level!=0)
			{
				if (gname(Node[i].type) == "NOT" || gname(Node[i].type) == "AND" || gname(Node[i].type) == "NAND" || gname(Node[i].type) == "NOR" || gname(Node[i].type) == "OR" || gname(Node[i].type) == "XOR")
				{
					Node[i].inivectors[1]=Node[i].vectors[0];
					Node[i].inivectors[3]=Node[i].vectors[1];

					for(flag = 0; flag <4; flag = flag + 2)
					{
						loc_indx= Node[i].indx;
						char vec[5] = {'x','x','x','x'};

						for(l = 0; l < 4; l++)
						{
							Node[i].possible_values[l] = '0';
						}

						if(flag == 0)
							Node[i].possible_values[0] = '1';
						else
							Node[i].possible_values[1] = '1';

						int vec_ind = 0;
						//call implication developed by shezad implication(loc_indx);

						for (j = 0; j < Npi; j++)
						{
							if (Pinput[j]->possible_values[0]==1)
							{
								vec[vec_ind]='0';
								vec_ind++;
								break;
							}
							else if (Pinput[j]->possible_values[1]==1)
                            {
                              vec[vec_ind]='1';
                              vec_ind++;
                              break;
                            }
                        }

						Node[i].inivectors[flag]= vec;
					}
				}
			}
	}
	/* page 66 assume c7 is 1 then we need atleast one of x3 and x4 as  1  if it is not so then if x3, x4 =1 and x2= 1 then c7 would be wrong to fix that we should make sure that none of PI has x.--Sourabh  */

}

//==============================TRANSITION DELAY FAULTS END===========================

//============================BACKTRACK START=============================================
/* Create struct as follows:
{}
int index
int typeOfProcessing
dynamic array to store index and possible values at an instance ArrayOfChangedValues[5]
int numOfNodes
}

The backtracking function will have an input of faultIndex which will be the index of the fault node, an indexStart index of the place we need to start processing once backtracked to that instance, and an int procType to say the type of processing we may do (for now i can think of 3 types of processings. Only backward implementation, Only Forward. Or both backward and forward implementation).

You will have a global dynamic array of the struc described above

strucType BacktrackingArray; // you can give it a more appropriate name
int numOfBacktracking; //keep track of number of backtracking states we have saved. When adding a state the number will bei incremented. When reading a state we read the last entered state so state will be read and then this number will be decremented.


store fault node as follows:
index into BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][0]
Store the possible_values array which will be 4 bits into BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][1:4]
increment BacktTrackingArray[numOfBacktracking]->numOfNodes

write a for loop to go through all the nodes(except the fault node) in the circuit when this function is called.
in this loop check if the possible_values array of that node has values [1,0,0,0] or [0,1,0,0]. If so, then store the index of that node in BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][0]
Store the possible_values array which will be [1,0,0,0] or [0,1,0,0] into BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][1:4]
increment BacktTrackingArray[numOfBacktracking]->numOfNodes


write a for loop to go through all the nodes(except the fault node) in the circuit that are in the transitive fanout of the fault index when this function is called.
in this loop check if the possible_values array of that node has values [1,1,1,1] . If not, then store the index of that node in BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][0]
Store the possible_values array  into BacktTrackingArray[numOfBacktracking]->ArrayOfChangedValues[numOfNodes][1:4]
increment BacktTrackingArray[numOfBacktracking]->numOfNodes

store the procType into BacktTrackingArray[numOfBacktracking]->typeOfProcessing
store the indexStart into BacktTrackingArray[numOfBacktracking]->index

increment numOfBacktracking; */
/*
//dynamic array to store index and possible values at an instance ArrayOfChangedValues[5]
struct bacTrack_struc {

       int index
       int typeOfProcessing
       int (*ArrayOfChangedValues)[5]
       int numOfNodes

};

backtrack(int faultIndex)
{
	printf("Need to backtrack");
	strucType BacktrackingArray; // you can give it a more appropriate name
	// Defined global as it cannot be changed ever
	//int numOfBacktracking; //keep track of number of backtracking states we have saved. When adding a state the number will bei incremented. When reading a state we read the last entered state so state will be read and then this number will be decremented.



}*/
//============================BACKTRACK END==============================================
//#endif

//============================LOGIC SIMULATION DROPPING START=================================
int logic_drop(char *test_vec, int node_val)
{
	int ret_val = 0;				// fail == 0 ***** pass == 1
	int i,j;

	// Was done for initialization of circuit.  Not needed Now
    // for(i = 0; i < Nnodes; i++)
	// {
        // sortedNodes[i].val = 0;
    // }

    for(j=0; j<5; j++)
	{
		printf("\nGenerating Random Input Vector %d\n", j);

		//Was used to generate random vectors. Not needed Now
		// for(i=0; i<Npi; i++)
		// {
			// input_vector[i] = rand()%2;
            // input_vector_pointer = 0;
			// printf("Value of input node %d = %d\n", sortedNodes[i].num, input_vector[i]);
        // }

		for(i = 0; i < Npi; i++)
		{
			if(i != node_val)	//to avoid overwriting data on PI after initialization
				input_vector[i] = test_vec[i];
		}

		for(i = 0; i < Nnodes; i++)
		{
            eval_drop(i);
		}

		for(i = 0; i < Npo; i++)
		{
			if(Poutput[i]->val == 1)
			{
				printf("Fault Dropped");
				ret_val = 1;
				break;
			}
	    }

        printf("\n\n");

		}

	return ret_val;
}


eval_drop(int xp)
{
	int i, temp1, temp2;

	if(gname(sortedNodes[xp].type)=="PI")
	{
        //   printf("adding value &d to node %d\n", input_vector[sortedNodes[xp].num-1], sortedNodes[xp].num);
		sortedNodes[xp].val = input_vector[input_vector_pointer];
        input_vector_pointer++;//input vector is a 5 location array that has values 1, 0 or -1(aka X)
	}

	else if (gname(sortedNodes[xp].type)=="BRANCH")
	{
		sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
	}

	else if(gname(sortedNodes[xp].type)=="NOT")
	{
		if(getNodeVal(sortedNodes[xp].unodes[0]->num)==0)
		{
            sortedNodes[xp].val = 1;
        }
		else if(getNodeVal(sortedNodes[xp].unodes[0]->num)==1)
		{
            sortedNodes[xp].val = 0;
        }
		else
		{
        sortedNodes[xp].val = -1;
        }
	}

	else if (gname(sortedNodes[xp].type)=="AND")
	{
		//create functions for AND, OR, NAND, NOR, and XOR that

		if(sortedNodes[xp].fin>1)
		{
			//printf("AND with more than 1 input\n");
			for(i=0; i<=sortedNodes[xp].fin-2; i++)
			{
				if(i==0)
				{
					temp1 = AND_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
				}
				else
				{
					temp1 = AND_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
				}

			}
            sortedNodes[xp].val = temp1;
        }
		else
		{
            //  printf("AND with 1 input\n");
            sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
            // printf("Assigned value %d to node %d because upnode[0] has value. Upnode node is %d out of %d nodes\n", sortedNodes[xp].val, sortedNodes[xp].num, sortedNodes[xp].unodes[xp]->num, sortedNodes[xp].fin);
        }
	}

	else if (gname(sortedNodes[xp].type)=="OR")
	{
		//create functions for AND, OR, NAND, NOR, and XOR that
		//  printf("found OR gate for node %d with fin &d\n", sortedNodes[xp].num, sortedNodes[xp].fin);
		if(sortedNodes[xp].fin>1)
		{
			for(i=0; i<=(sortedNodes[xp].fin-2); i++)
			{
				if(i==0)
				{
					//  printf("calling OR function for the first time for node %d with inputs %d and %d\n", sortedNodes[xp].num,sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num);
					temp1 = OR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
				}
				else
				{
					temp1 = OR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
				}
			}

			sortedNodes[xp].val = temp1;
		}
		else
		{
			sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
		}
	}

	else if (gname(sortedNodes[xp].type)=="NAND")
	{
		//create functions for AND, OR, NAND, NOR, and XOR that
		if(sortedNodes[xp].fin>1)
		{
			for(i=0; i<=sortedNodes[xp].fin-2; i++)
			{
				if(i==0)
				{
					temp1 = NAND_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
				}
				else
				{
					temp1 = NAND_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
				}
			}
			sortedNodes[xp].val = temp1;
		}
		else
		{
			sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
		}
	}

	else if (gname(sortedNodes[xp].type)=="NOR")
	{
		//create functions for AND, OR, NAND, NOR, and XOR that
		if(sortedNodes[xp].fin>1)
		{
			for(i=0; i<=sortedNodes[xp].fin-2; i++)
			{
				if(i==0)
				{
					temp1 = NOR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
				}
				else
				{
					temp1 = NOR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
				}
			}
			sortedNodes[xp].val = temp1;
		}
		else
		{
			sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
		}
	}

	else if (gname(sortedNodes[xp].type)=="XOR")
	{
		//create functions for AND, OR, NAND, NOR, and XOR that
		if(sortedNodes[xp].fin>1)
		{
			for(i=0; i<=sortedNodes[xp].fin-2; i++)
			{
				if(i==0)
				{
					temp1 = XOR_gate(getNodeVal(sortedNodes[xp].unodes[0]->num), getNodeVal(sortedNodes[xp].unodes[1]->num));
				}
				else
				{
					temp1 = XOR_gate(temp1, getNodeVal(sortedNodes[xp].unodes[i+1]->num));
				}
			}
			sortedNodes[xp].val = temp1;
		}
		else
		{
			sortedNodes[xp].val = getNodeVal(sortedNodes[xp].unodes[0]->num);
		}
	}
}
//============================LOGIC SIMULATION DROPPING END=================================




//==========================FUNCTION TO PRINT FINAL STUFF=============================
print_all()
{
	int i, j;
	FILE *pntall;

	if((pntall = fopen("Overall_Results.txt","w")) == NULL)
	{
		printf("Cannot create the final file\n");
		return;
	}

	fprintf(pntall, " Node  \t Type \t\t SA0 \t\t SA1 \t\t STR \t\t STF \n");
	fprintf(pntall, " ----- \t ---- \t\t-----\t\t-----\t\t-----\t\t-----\n");


	for(i = 0; i<Nnodes; i++)
	{
		fprintf(pntall, "%d\t", i);
		fprintf(pntall, "%s\t", Node[i].type);
		fprintf(pntall, "%s\t", Node[i].vectors[0]);
		fprintf(pntall, "%s\t", Node[i].vectors[1]);
		fprintf(pntall, "%s\t", Node[i].inivectors[0]);
		fprintf(pntall, "%s\t", Node[i].inivectors[2]);
	}

	fclose(pntall);
}
//==========================FUNCTION TO PRINT FINAL STUFF=============================
